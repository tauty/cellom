= Introduction =

Cellomは、Java向けの集計表作成ライブラリです。

作成した集計表はPOIを使ってExcelとして出力したり、HTMLのテーブルとして出力したりできます。

= 使い方 =

ここでは、下記のデータを元に･･･


 * 株式会社 日本○○○○の社員構成
|| *年齢*|| *性別*|| *拠点*|| *職種*||
||21||男性||名古屋本社||エンジニア||
||23||女性||名古屋本社||エンジニア||
||25||女性||名古屋本社||エンジニア||
||30||男性||名古屋本社||エンジニア||
||35||男性||名古屋本社||エンジニア||
||40||男性||名古屋本社||エンジニア||
||52||男性||名古屋本社||エンジニア||
||55||男性||名古屋本社||エンジニア||
||34||女性||名古屋本社||事務||
||51||男性||名古屋本社||営業||
||22||男性||東京支社||エンジニア||
||24||男性||東京支社||エンジニア||
||25||男性||東京支社||エンジニア||
||28||男性||東京支社||エンジニア||
||31||男性||東京支社||エンジニア||
||36||女性||東京支社||エンジニア||
||37||男性||東京支社||エンジニア||
||42||男性||東京支社||エンジニア||
||24||女性||東京支社||事務||
||28||男性||東京支社||事務||
||30||男性||東京支社||営業||
||25||男性||大阪支社||エンジニア||
||30||男性||大阪支社||エンジニア||
||37||男性||大阪支社||エンジニア||
||21||女性||大阪支社||事務||
||30||女性||大阪支社||営業||

<br><br>
下記集計表を作成する処理を通して、Cellomの基本的な使い方を学びます。
 * 株式会社 日本○○○○の社員構成
<table border="1">
	<thead>
		<tr>
			<th rowspan="2" style="HEADER">世代</th>
			<th colspan="4" style="HEADER">名古屋本社</th>
			<th colspan="4" style="HEADER">東京支社</th>
			<th colspan="4" style="HEADER">大阪支社</th>
			<th rowspan="2" style="HEADER">合計</th>
		</tr>
		<tr>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="BODY">20代</td>
			<td style="BODY">3</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">3</td>
			<td style="BODY">4</td>
			<td style="BODY">2</td>
			<td style="BODY">0</td>
			<td style="BODY">6</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">2</td>
			<td style="BODY">11</td>
		</tr>
		<tr>
			<td style="BODY">30代</td>
			<td style="BODY">2</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">3</td>
			<td style="BODY">3</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">4</td>
			<td style="BODY">2</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">3</td>
			<td style="BODY">10</td>
		</tr>
		<tr>
			<td style="BODY">40代</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">2</td>
		</tr>
		<tr>
			<td style="BODY">50代</td>
			<td style="BODY">2</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">3</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">3</td>
		</tr>
		<tr>
			<td style="BODY">総計</td>
			<td style="BODY">8</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">10</td>
			<td style="BODY">8</td>
			<td style="BODY">2</td>
			<td style="BODY">1</td>
			<td style="BODY">11</td>
			<td style="BODY">3</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">5</td>
			<td style="BODY">26</td>
		</tr>
	</tbody>
</table>

まずはテストデータの準備を行います。

※ 実際にはRDBMSやCSVファイルなどから読み込む処理になる箇所ですが、ここではサンプルとして下記のようにJavaで実装しています。

{{{
enum Sex {
	MALE, FEMALE
}

class Employee {
	final int age;
	final Sex sex;
	final String section;
	final String title;

	Employee(int age, Sex sex, String section, String title) {
		this.age = age;
		this.sex = sex;
		this.section = section;
		this.title = title;
	}
}

public class SampleTest {

	List<Employee> employees;

	@Before
	public void setUp() {
		employees = new ArrayList<Employee>();

		// 名古屋本社
		employees.add(new Employee(21, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(23, Sex.FEMALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(25, Sex.FEMALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(30, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(35, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(40, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(52, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(55, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(34, Sex.FEMALE, "名古屋本社", "事務"));
		employees.add(new Employee(51, Sex.MALE, "名古屋本社", "営業"));

		// 東京支社
		employees.add(new Employee(22, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(24, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(25, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(28, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(31, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(36, Sex.FEMALE, "東京支社", "エンジニア"));
		employees.add(new Employee(37, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(42, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(24, Sex.FEMALE, "東京支社", "事務"));
		employees.add(new Employee(28, Sex.MALE, "東京支社", "事務"));
		employees.add(new Employee(30, Sex.MALE, "東京支社", "営業"));

		// 大阪支社
		employees.add(new Employee(25, Sex.MALE, "大阪支社", "エンジニア"));
		employees.add(new Employee(30, Sex.MALE, "大阪支社", "エンジニア"));
		employees.add(new Employee(37, Sex.MALE, "大阪支社", "エンジニア"));
		employees.add(new Employee(21, Sex.FEMALE, "大阪支社", "事務"));
		employees.add(new Employee(30, Sex.FEMALE, "大阪支社", "営業"));
	}


                           :
                           :
                           :
                           :
}

}}}

このデータを元に集計表を作成します。

== 集計表の構造を表現するクラスの作成 ==

上記集計表の構造は、下記のようになっています。
{{{
・世代
・名古屋本社
	・エンジニア
	・事務
	・営業
	・小計
・東京支社
	・エンジニア
	・事務
	・営業
	・小計
・大阪支社
	・エンジニア
	・事務
	・営業
	・小計
・合計
}}}

つまり、「世代」「合計」に挟まれる形で、「エンジニア」「事務」「営業」「小計」という子要素を持つ、同じ構造のものが繰り返し登場しています。まずはこれをJavaのクラスとして下記のように表現します。

{{{
class Table {
	@Header(title = "世代")
	String generation;

	@EachHeader
	CelloMap<Section> sectionMap = CelloMap.create(Section.class);

	@Header(title = "合計")
	int sum;
}

class Section {
	@EachHeader
	CelloMap<Integer> titleMap = CelloMap.create(Integer.class);

	@Header(title = "小計")
	int sum;
}
}}}

「同じ構造のものが複数回登場する」というのを、ここでは「CelloMap」というCellomのクラスを用いて表現しています。このクラスはCelloMap.createメソッドに構造を表現するクラスのクラスオブジェクトをパラメタとして渡して生成します。CelloMapは集計表で同じ構造のものが何回登場するのか事前に分からないときなどに便利です。例えば集計表に表示しなければならない支社の数が不明な場合などに使用します。

今回のケースを、もしCelloMapを使用しないでクラスで表現すると、下記のようになります。
{{{
class Table {
	@Header(title = "世代")
	String generation;

	@Header(title = "名古屋本社")
	Section nagoya;

	@Header(title = "東京支社")
	Section tokyo;

	@Header(title = "大阪支社")
	Section osaka;

	@Header(title = "合計")
	int sum;
}

class Section {
	@Header(title = "エンジニア")
	int engineer;

	@Header(title = "事務")
	int jimu;

	@Header(title = "営業")
	int eigyo;

	@Header(title = "小計")
	int sum;
}
}}}

事前に集計表に表示される内容が全て判明している場合には、この書き方でも良いでしょう。

なお、各フィールドにはアノテーションが付与されています。「@Header」は通常のフィールドにヘッダ行の定義を行うアノテーションで、ここではヘッダ行に表示される文字列を定義しています。「@EachHeader」はCelloMapに対するヘッダ行の定義を行うアノテーションですが、ここでは単に集計表に表示される対象であることを明示するために使用しています。

== 集計表作成 ～ 通常編 ～ ==

集計表は、下記のように作成します。

{{{
	@Test
	public void normal() {

		TableManager<Table> tm = TableManager.create(Table.class);
		rowSetting(tm, 20, 30, 40, 50);

		for (Employee e : employees) {

			// 社員の世代取得
			String generation = getGeneration(e.age);

			// 世代別行への反映
			updateEmployee(tm.row(generation).get(), e);

			// 総計行への反映
			updateEmployee(tm.footer().get(), e);
		}

		assertEqualsWithFile(new HtmlGenerator().generate(tm), getClass(),
				"normal");
	}

	// 行初期設定
	private void rowSetting(TableManager<Table> tm, int... ages) {

		// 各世代行の生成
		for (int age : ages) {
			String generation = getGeneration(age);
			tm.row(generation).get().generation = generation;
		}

		// 総計行の生成
		tm.footer("総計").get().generation = "総計";
	}

	// 年齢から世代を求める
	private String getGeneration(int age) {
		if (age < 30)
			return "20代";
		if (age < 40)
			return "30代";
		if (age < 50)
			return "40代";
		return "50代";
	}

	// 社員情報のTableオブジェクトへの反映
	private void updateEmployee(Table table, Employee e) {
		Section section = table.sectionMap.get(e.section);

		// 各職種ごとに+1
		section.titleMap.set(e.title, section.titleMap.get(e.title) + 1);

		// 小計に+1
		section.sum++;

		// 合計に+1
		table.sum++;
	}
}}}

先ほど作成したクラスのクラスオブジェクトをパラメタとして、「TableManager」というクラスのインスタンスを生成します。こちらを使うと、指定された行の取得・生成などを自動的に行うことができます。

上記ソースは、社員のデータ一人分につき所属する世代の行と総計の行を取得し、それぞれに対し所属する支社(or 本社)・職種のセルと、その小計、合計に対して +1を行う、という処理を行っています。TableManagerのインスタンスを「HtmlGenerator」というクラスを使用すると、下記のように集計表のHTMLソースのコードを出力することができます。

{{{
<table border="1">
	<thead>
		<tr>
			<th rowspan="2" style="HEADER">世代</th>
			<th colspan="4" style="HEADER">名古屋本社</th>
			<th colspan="4" style="HEADER">東京支社</th>
			<th colspan="4" style="HEADER">大阪支社</th>
			<th rowspan="2" style="HEADER">合計</th>
		</tr>
		<tr>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="BODY">20代</td>
			<td style="BODY">3</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">3</td>
			<td style="BODY">4</td>
			<td style="BODY">2</td>
			<td style="BODY">0</td>
			<td style="BODY">6</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">2</td>
			<td style="BODY">11</td>
		</tr>
				:
			　　(中略)
				:
		<tr>
			<td style="BODY">総計</td>
			<td style="BODY">8</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">10</td>
			<td style="BODY">8</td>
			<td style="BODY">2</td>
			<td style="BODY">1</td>
			<td style="BODY">11</td>
			<td style="BODY">3</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">5</td>
			<td style="BODY">26</td>
		</tr>
	</tbody>
</table>
}}}

※ ソース内に登場する、「assertEqualsWithFile」というメソッドはauty4junitという単体テスト補助ツールのメソッドです。

== 集計表作成 ～ クエリ編 ～ ==

Cellomではクエリという機能が用意されており、こちらを使うとより短いコードで集計処理を行うことができます。上記と同じ処理を行っているソースが下記です。

{{{
	@Test
	public void query() {
		TableManager<Table> tm = TableManager.create(Table.class);
		rowSetting(tm, 20, 30, 40, 50);

		for (Employee e : employees) {
			String generation = getGeneration(e.age);

			// 更新対象のセル取得用クエリ
			String query = generation + ",総計|@sum,sectionMap|" + e.section
					+ "|@sum,titleMap|" + e.title;
			
			// クエリを発行し、更新対象を一気に+1
			for (Cell<Integer> cell : tm.getByQuery(Integer.class, query)) {
				cell.add(1);
			}
		}

		assertEqualsWithFile(new HtmlGenerator().generate(tm), getClass(),
				"query");
	}
}}}

出力される結果は上記と全く同じなので、割愛します。

クエリとは、TableManagerから条件に合致するものをCellオブジェクトとして一気に取得するための仕組みで、複数個所に同一の数を足す必要のある集計表では便利な仕組みです。<br>
Cellオブジェクトとは、集計表を作成したときのフィールド一つ一つと対応するオブジェクトで、値の操作の他にも、スタイルの設定、幅の設定、値の変換設定などを行うことができます。
Cellomのクエリは、下記のような構成になっています。<br>
　　[行指定箇所]|[フィールド or CelloMapのkey名指定箇所]|[フィールド or CelloMapのkey名指定箇所]|...<br>
先頭にくるのは行指定箇所で、ここでは行につけた名前(今回のケースでは「20代」・「30代」・「総計」等)を使ってアクセスしています。行指定には他にも全行指定「`*`」やカレント行指定の「.」などがあります。「,」で区切ることで、複数行を指定することが可能です。<br>
行指定の後には、クラスのフィールド or CelloMapに登録されたkey名を指定します。クラス・CelloMapの下に更なるクラス・CelloMapが登録されている場合には「|」でつないで何階層でも辿って特定のフィールドを指定することができます。行指定と同様に、「,」で区切ることで複数指定することもできます。なおCellオブジェクトとして返却されるのは一番最後に指定されたフィールドと、「@」が先頭に付与されたフィールドです。<br>
例として、上記のquery生成でもしEmployeeが30代で東京支社のエンジニアだった場合に生成されるクエリーは、<br><br>
　　30代,総計|@sum,sectionMap|東京支社|@sum,titleMap|エンジニア<br>
となります。これにより、Table#sumフィールド、Table#sectionMap#東京支社#sum, Table#sectionMap#東京支社#titleMap#エンジニアの3フィールドが、「30代」「総計」の2行分取得されるので、合計6フィールド分のCellオブジェクトが取得されます。

== エクセル出力 ==

今度は作成した集計表をエクセルとして出力してみましょう。

[https://code.google.com/p/cellom/source/browse/cellom/sample_image/sampleXls1.PNG]