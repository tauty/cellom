
= Introduction =

Cellomは、Java向けの集計表作成ライブラリです。

作成した集計表はPOIを使ってExcelとして出力したり、HTMLのテーブルとして出力したりできます。

= 使い方 =

ここでは、下記のデータを元に･･･


 * 株式会社 日本○○○○の社員構成
|| *年齢*|| *性別*|| *拠点*|| *職種*||
||21||男性||名古屋本社||エンジニア||
||23||女性||名古屋本社||エンジニア||
||25||女性||名古屋本社||エンジニア||
||30||男性||名古屋本社||エンジニア||
||35||男性||名古屋本社||エンジニア||
||40||男性||名古屋本社||エンジニア||
||52||男性||名古屋本社||エンジニア||
||55||男性||名古屋本社||エンジニア||
||34||女性||名古屋本社||事務||
||51||男性||名古屋本社||営業||
||22||男性||東京支社||エンジニア||
||24||男性||東京支社||エンジニア||
||25||男性||東京支社||エンジニア||
||28||男性||東京支社||エンジニア||
||31||男性||東京支社||エンジニア||
||36||女性||東京支社||エンジニア||
||37||男性||東京支社||エンジニア||
||42||男性||東京支社||エンジニア||
||24||女性||東京支社||事務||
||28||男性||東京支社||事務||
||30||男性||東京支社||営業||
||25||男性||大阪支社||エンジニア||
||30||男性||大阪支社||エンジニア||
||37||男性||大阪支社||エンジニア||
||21||女性||大阪支社||事務||
||30||女性||大阪支社||営業||

<br><br>
下記集計表を作成する処理を通して、Cellomの基本的な使い方を学びます。
 * 株式会社 日本○○○○の社員構成
<table border="1">
	<thead>
		<tr>
			<th rowspan="2" style="HEADER">世代</th>
			<th colspan="4" style="HEADER">名古屋本社</th>
			<th colspan="4" style="HEADER">東京支社</th>
			<th colspan="4" style="HEADER">大阪支社</th>
			<th rowspan="2" style="HEADER">合計</th>
		</tr>
		<tr>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="BODY">20代</td>
			<td style="BODY">3</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">3</td>
			<td style="BODY">4</td>
			<td style="BODY">2</td>
			<td style="BODY">0</td>
			<td style="BODY">6</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">2</td>
			<td style="BODY">11</td>
		</tr>
		<tr>
			<td style="BODY">30代</td>
			<td style="BODY">2</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">3</td>
			<td style="BODY">3</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">4</td>
			<td style="BODY">2</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">3</td>
			<td style="BODY">10</td>
		</tr>
		<tr>
			<td style="BODY">40代</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">2</td>
		</tr>
		<tr>
			<td style="BODY">50代</td>
			<td style="BODY">2</td>
			<td style="BODY">0</td>
			<td style="BODY">1</td>
			<td style="BODY">3</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">3</td>
		</tr>
		<tr>
			<td style="BODY">総計</td>
			<td style="BODY">8</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">10</td>
			<td style="BODY">8</td>
			<td style="BODY">2</td>
			<td style="BODY">1</td>
			<td style="BODY">11</td>
			<td style="BODY">3</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">5</td>
			<td style="BODY">26</td>
		</tr>
	</tbody>
</table>

まずはテストデータの準備を行います。

※ 実際にはRDBMSやCSVファイルなどから読み込む処理になる箇所ですが、ここではサンプルとして下記のようにJavaで実装しています。

{{{
enum Sex {
	MALE, FEMALE
}

class Employee {
	final int age;
	final Sex sex;
	final String section;
	final String title;

	Employee(int age, Sex sex, String section, String title) {
		this.age = age;
		this.sex = sex;
		this.section = section;
		this.title = title;
	}
}

public class SampleTest {

	List<Employee> employees;

	@Before
	public void setUp() {
		employees = new ArrayList<Employee>();

		// 名古屋本社
		employees.add(new Employee(21, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(23, Sex.FEMALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(25, Sex.FEMALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(30, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(35, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(40, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(52, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(55, Sex.MALE, "名古屋本社", "エンジニア"));
		employees.add(new Employee(34, Sex.FEMALE, "名古屋本社", "事務"));
		employees.add(new Employee(51, Sex.MALE, "名古屋本社", "営業"));

		// 東京支社
		employees.add(new Employee(22, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(24, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(25, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(28, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(31, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(36, Sex.FEMALE, "東京支社", "エンジニア"));
		employees.add(new Employee(37, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(42, Sex.MALE, "東京支社", "エンジニア"));
		employees.add(new Employee(24, Sex.FEMALE, "東京支社", "事務"));
		employees.add(new Employee(28, Sex.MALE, "東京支社", "事務"));
		employees.add(new Employee(30, Sex.MALE, "東京支社", "営業"));

		// 大阪支社
		employees.add(new Employee(25, Sex.MALE, "大阪支社", "エンジニア"));
		employees.add(new Employee(30, Sex.MALE, "大阪支社", "エンジニア"));
		employees.add(new Employee(37, Sex.MALE, "大阪支社", "エンジニア"));
		employees.add(new Employee(21, Sex.FEMALE, "大阪支社", "事務"));
		employees.add(new Employee(30, Sex.FEMALE, "大阪支社", "営業"));
	}


                           :
                           :
                           :
                           :
}

}}}

このデータを元に集計表を作成します。

== 集計表の構造を表現するクラスの作成 ==

上記集計表の構造は、下記のようになっています。
{{{
・世代
・名古屋本社
	・エンジニア
	・事務
	・営業
	・小計
・東京支社
	・エンジニア
	・事務
	・営業
	・小計
・大阪支社
	・エンジニア
	・事務
	・営業
	・小計
・合計
}}}

つまり、「世代」「合計」に挟まれる形で、「エンジニア」「事務」「営業」「小計」という子要素を持つ、同じ構造のものが繰り返し登場しています。まずはこれをJavaのクラスとして下記のように表現します。

{{{
class Table {
	@Header(title = "世代")
	String generation;

	@EachHeader
	CelloMap<Section> sectionMap = CelloMap.create(Section.class);

	@Header(title = "合計")
	int sum;
}

class Section {
	@EachHeader
	CelloMap<Integer> titleMap = CelloMap.create(Integer.class);

	@Header(title = "小計")
	int sum;
}
}}}

「同じ構造のものが複数回登場する」というのを、ここでは「CelloMap」というCellomのクラスを用いて表現しています。このクラスはCelloMap.createメソッドに構造を表現するクラスのクラスオブジェクトをパラメタとして渡して生成します。CelloMapは集計表で同じ構造のものが何回登場するのか事前に分からないときなどに便利です。例えば集計表に表示しなければならない支社の数が不明な場合などに使用します。

今回のケースを、もしCelloMapを使用しないでクラスで表現すると、下記のようになります。
{{{
class Table {
	@Header(title = "世代")
	String generation;

	@Header(title = "名古屋本社")
	Section nagoya;

	@Header(title = "東京支社")
	Section tokyo;

	@Header(title = "大阪支社")
	Section osaka;

	@Header(title = "合計")
	int sum;
}

class Section {
	@Header(title = "エンジニア")
	int engineer;

	@Header(title = "事務")
	int jimu;

	@Header(title = "営業")
	int eigyo;

	@Header(title = "小計")
	int sum;
}
}}}

事前に集計表に表示される内容が全て判明している場合には、この書き方でも良いでしょう。

なお、各フィールドにはアノテーションが付与されています。「@Header」は通常のフィールドにヘッダ行の定義を行うアノテーションで、ここではヘッダ行に表示される文字列を定義しています。「@EachHeader」はCelloMapに対するヘッダ行の定義を行うアノテーションですが、ここでは単に集計表に表示される対象であることを明示するために使用しています。

== 集計表作成 ～ 通常編 ～ ==

集計表は、下記のように作成します。

{{{
	@Test
	public void normal() {

		TableManager<Table> tm = TableManager.create(Table.class);

		for (Employee e : employees) {

			String generation = getGeneration(e.age);

			// 世代別行への反映
			Table table = tm.row(generation).get();
			table.generation = generation;
			updateEmployee(table, e);

			// 総計行の生成
			table = tm.footer().get();
			table.generation = "総計";
			updateEmployee(table, e);
		}

		assertEqualsWithFile(new HtmlGenerator().generate(tm), getClass(),
				"normal");
	}

	private String getGeneration(int age) {
		if (age < 20)
			return "10代";
		if (age < 30)
			return "20代";
		if (age < 40)
			return "30代";
		if (age < 50)
			return "40代";
		if (age < 60)
			return "50代";
		return "定年後";
	}

	private void updateEmployee(Table table, Employee e) {
		Section section = table.sectionMap.get(e.section);

		// 各職種ごとに+1
		section.titleMap.set(e.title, section.titleMap.get(e.title) + 1);

		// 小計に+1
		section.sum++;

		// 合計に+1
		table.sum++;
	}
}}}

先ほど作成したクラスのクラスオブジェクトをパラメタとして、「TableManager」というクラスのインスタンスを生成します。こちらを使うと、指定された行の取得・生成などを自動的に行うことができます。

上記ソースは、社員のデータ一人分につき所属する世代の行と総計の行を取得し、それぞれに対し所属する支社(or 本社)・職種のセルと、その小計、合計に対して +1を行う、という処理を行っています。TableManagerのインスタンスを「HtmlGenerator」というクラスを使用すると、下記のように集計表のHTMLソースのコードを出力することができます。

{{{
<table border="1">
	<thead>
		<tr>
			<th rowspan="2" style="HEADER">世代</th>
			<th colspan="4" style="HEADER">名古屋本社</th>
			<th colspan="4" style="HEADER">東京支社</th>
			<th colspan="4" style="HEADER">大阪支社</th>
			<th rowspan="2" style="HEADER">合計</th>
		</tr>
		<tr>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
			<th style="HEADER">エンジニア</th>
			<th style="HEADER">事務</th>
			<th style="HEADER">営業</th>
			<th style="HEADER">小計</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="BODY">20代</td>
			<td style="BODY">3</td>
			<td style="BODY">0</td>
			<td style="BODY">0</td>
			<td style="BODY">3</td>
			<td style="BODY">4</td>
			<td style="BODY">2</td>
			<td style="BODY">0</td>
			<td style="BODY">6</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">0</td>
			<td style="BODY">2</td>
			<td style="BODY">11</td>
		</tr>
				:
			　(中略)
				:
		<tr>
			<td style="BODY">総計</td>
			<td style="BODY">8</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">10</td>
			<td style="BODY">8</td>
			<td style="BODY">2</td>
			<td style="BODY">1</td>
			<td style="BODY">11</td>
			<td style="BODY">3</td>
			<td style="BODY">1</td>
			<td style="BODY">1</td>
			<td style="BODY">5</td>
			<td style="BODY">26</td>
		</tr>
	</tbody>
</table>
}}}

※ ソース内に登場する、「assertEqualsWithFile」というメソッドはauty4junitという単体テスト補助ツールのメソッドです。

== 集計表作成 ～ クエリ編 ～ ==

Cellomではクエリという機能が用意されており、こちらを使うとより短いコードで集計処理を行うことができます。上記と同じ処理を行っているソースが下記です。

{{{
	@Test
	public void query() {
		TableManager<Table> tm = TableManager.create(Table.class);
		rowSetting(tm, 20, 30, 40, 50);

		for (Employee e : employees) {
			String generation = getGeneration(e.age);
			String query = generation + ",総計|@sum,sectionMap|" + e.section
					+ "|@sum,titleMap|" + e.title;
			for (Cell<Integer> cell : tm.getByQuery(Integer.class, query)) {
				cell.add(1);
			}
		}

		assertEqualsWithFile(new HtmlGenerator().generate(tm), getClass(),
				"query");
	}

	private void rowSetting(TableManager<Table> tm, int... ages) {
		for (int age : ages) {
			String generation = getGeneration(age);
			tm.row(generation).get().generation = generation;
		}
		tm.footer("総計").get().generation = "総計";
	}
}}}

出力される結果は上記と全く同じなので、割愛します。

クエリとはTableManagerに登録されたものの内、

